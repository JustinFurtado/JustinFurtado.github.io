{
    "gamelibraries":{
        "imageData" : {
            "count": 14, 
            "paths": ["../../images/Engine/GameLibraries/TwoTriangles.png",
                      "../../images/Engine/GameLibraries/MultipleQuads.png",
                      "../../images/Engine/GameLibraries/ThreeD.png",
                      "../../images/Engine/GameLibraries/FPS.png",
                      "../../images/Engine/GameLibraries/ThreeDSpace.png",
                      "../../images/Engine/GameLibraries/Camera.png",
                      "../../images/Engine/GameLibraries/Collision.png",
                      "../../images/Engine/GameLibraries/ObjLoader.png",
                      "../../images/Engine/GameLibraries/Textures.png",
                      "../../images/Engine/GameLibraries/MoreTextures.png",
                      "../../images/Engine/GameLibraries/Lighting.png",
                      "../../images/Engine/GameLibraries/BetterLighting.png",
                      "../../images/Engine/GameLibraries/Raycasting.png",
                      "../../images/Engine/GameLibraries/DestructibleTerrain.png"],
            "titles": ["Lab 2: Shaders",
                       "Lab 3: Bouncing Quads", 
                       "Lab 4: A New Dimmension", 
                       "Lab 5: FPS", 
                       "Lab 6: 3D Space", 
                       "Lab 7: Camera", 
                       "Lab 8: Collision", 
                       "Lab 9: Obj Loading", 
                       "Lab 10: Textures", 
                       "Lab 11: A New Scene", 
                       "Lab 12: Lighting", 
                       "Lab 13: Entity Component System", 
                       "Lab 14: Raycasting", 
                       "Lab 15: Spatial Partitioning V1"],
            "descriptions": ["The first successful implementation of drawing colored triangles to the screen with OpenGL and GLSL", 
                             "Taking the triangles a bit further, and adding some logic to them, I managed to get several quads bouncing around in screen-space in this early version of my game engine.", 
                             "Passing data around the engine in new ways and toying with the OpenGL state allowed me to draw 3D shapes in my engine!", 
                             "At this point, framerate-dependent movement was starting to become a noticable issue with window resizing, so it was time to get the system time and calculate the delta times to pass around for framerate-independent object motion. It was also useful for calculating FPS.", 
                             "Adjusting shaders to allow for objects to be placed in 3D space in a better way and moving the objects around a bit.", 
                             "Adding a camera to view the moved objects from other angles, and thus exist inside our world.", 
                             "Simple bounding box/bounding sphere collisions with the camera and object allow me to finally make a simple game in my engine! It is very simple. Find the house in the giant box of shapes to win. [Cannot be run in-browser, contact me if interested in seeing]", 
                             "Oh finally, not having to type vertices by hand to render shapes on the screen! I manually parse data from .obj files to get any shape in my engine and demo it with several models!", 
                             "With model loading then comes the desire to load textured models. Passing around some UV data, loading textures into OpenGL and writing more GLSL shaders allows for much better-looking models!", 
                             "Upgrades to model loading, configuration files, the demo world, shaders, etc, allow for a new experience to be had.", 
                             "Writing a Phong shader in GLSL, passing around normal data, and creating a demo scene allow for things to start looking even better.", 
                             "Refactoring much of the game and engine to support entities and components make coding a flying dragon easier and cleaner while giving us more future potential and freedom for expansion upon the game.", 
                             "The ability to check if a ray touches a triangle is a very handy thing to have into a game. It can be seen in this assignment by firing red blocks that stick to the walls.", 
                             "Even a simple spatial partitioning scheme is better than none. One is implemented here, allowing far more rays to be cast, and, through this, our dragon to breathe fire and destroy blocks."]
        }
    },
    "computergraphics":{
        "imageData" : {
            "count": 22, 
            "paths": ["../../images/Engine/ComputerGraphics/TeapotsLabOne.png",
                      "../../images/Engine/ComputerGraphics/TeapotsLabTwo.png",
                      "../../images/Engine/ComputerGraphics/TeapotsLabThree.png",
                      "../../images/Engine/ComputerGraphics/LabThreeCel.png",
                      "../../images/Engine/ComputerGraphics/LabThreeFog.png",
                      "../../images/Engine/ComputerGraphics/LabThreeMultiple.png",
                      "../../images/Engine/ComputerGraphics/LabThreeSpotlight.png",
                      "../../images/Engine/ComputerGraphics/LabFourCrate.png",
                      "../../images/Engine/ComputerGraphics/LabFourFrameBuffer.png",
                      "../../images/Engine/ComputerGraphics/LabFourMultiple.png",
                      "../../images/Engine/ComputerGraphics/LabFourNormalMap.png",
                      "../../images/Engine/ComputerGraphics/LabFourTransparency.png",
                      "../../images/Engine/ComputerGraphics/LabFiveHair.png",
                      "../../images/Engine/ComputerGraphics/LabFiveFractal.png",
                      "../../images/Engine/ComputerGraphics/LabFiveParticles.png",
                      "../../images/Engine/ComputerGraphics/LabFiveWireframes.png",
                      "../../images/Engine/ComputerGraphics/LabSixBlur.png",
                      "../../images/Engine/ComputerGraphics/LabSixShadows.png",
                      "../../images/Engine/ComputerGraphics/LabSixVolumetricShadows.png",
                      "../../images/Engine/ComputerGraphics/LabSevenParticleFire.png",
                      "../../images/Engine/ComputerGraphics/LabSevenPlane.png",
                      "../../images/Engine/ComputerGraphics/Final.png"],
            "titles": ["Lab 1: Teapots",
                       "Lab 2: More Teapots", 
                       "Lab 3: Even more Teapots", 
                       "Lab 3: Cel shading", 
                       "Lab 3: Fog", 
                       "Lab 3: Multiple lights", 
                       "Lab 3: Spotlight", 
                       "Lab 4: Crate", 
                       "Lab 4: FrameBuffer", 
                       "Lab 4: Multiple Textures", 
                       "Lab 4: Normal Map", 
                       "Lab 4: Transparency", 
                       "Lab 5: Normal Hair", 
                       "Lab 5: Fractals", 
                       "Lab 5: More Fractals",
                       "Lab 5: Wireframes",
                       "Lab 6: Blur",
                       "Lab 6: Shadows",
                       "Lab 6: Volumetric Shadows",
                       "Lab 7: Particle Fire",
                       "Lab 7: Plane",
                       "Final Assignment"],
            "descriptions": ["A simple lab for which we lit teapots using phong lighting.", 
                             "A lab in which we lit several teapots using different shaders and shader techniques, including subroutines, to show our engines were flexible enough to handle it.", 
                             "Part of lab 3, where we showed the difference between point lighting and directional lighting on teapots. Depending on light placement, it can be hard to see.", 
                             "Another part of lab 3, where we wrote a shader to quantize lighting values to get cel shading with specifyable number of light levels.", 
                             "Another part of lab 3, where we wrote a fog shader so that further away objects using this shader get foggier. Demonstrated on a stack of dragon models made by me.", 
                             "Another part of lab 3, where we wrote a shader that accepts multiple light sources so our objects can be lit using more than a single light source.", 
                             "Another part of lab 3, where we wrote a shader that lights an area with a spotlight, rather than a point light or directional light.", 
                             "Here we light a textured model. Pretty simple modification of previous shaders.", 
                             "Here we render in multiple passes for the first time. By rendering from a secondary camera to a framebuffer, and using that as a texture on the cube, we get a representation of the world on a surface within the world.", 
                             "Here we write a new shader that allows us to use multiple textures on the same model. First a cement texture, followed by a moss texture with transparency.", 
                             "Here I wrote a shader that takes in a normal map to use for lighting, giving the illusion of a more detailed surface than is actually present. It is actually just a cube, but the sides light as if there is geometry present even as the light is moved.", 
                             "Here I write a shader that takes in a mask to determine which fragements to discard to allow for part of a texture to be applied to a model without having to alter the blend state or alpha values.", 
                             "Here, using a geometry shader, the normals of the faces of, and the vertices of, a model are drawn as lines protruding from the mesh.", 
                             "Here I applied a fractal shader that I wrote extracurricularly to a billboard for the billboarding assignment.", 
                             "Here I take strong advantage of the per-pixel intensity of my shader to render 200,000 planes with fractal shaders on them, that become more clear as you approach them.", 
                             "Here we write a wireframe shader to display on lines on top of a model so triangles can be identified.", 
                             "Here shadows are blurred to make the edges appear smoother and make pixelation less visible.", 
                             "Here shadows are rendered using a depth texture and a custom shader.", 
                             "Here shadows are made pixel-perfect in a less-efficient manner by using a more complicated technique involving shadow volumes.", 
                             "Transparency, billboards, geometry shaders, combined and used over and over to make particles.", 
                             "A shader makes use of a sine curve to turn a flat plane into a continuously moving wavy plane by passing in time, amplitude, etc. to the shader.",
                             "For the final assignment, I implemented edge detection and made a simple 3D matching game, where you must find and click the object whose edges are shown in the full 3D world."]
        }
    },
    "ai":{
        "imageData" : {
            "count": 22, 
            "paths": ["../../images/Engine/AI/BetterPartition.png",
                      "../../images/Engine/AI/WorldEditEmpty.png",
                      "../../images/Engine/AI/WorldEditPlace.png",
                      "../../images/Engine/AI/WorldEditRemove.png",
                      "../../images/Engine/AI/WorldEditTranslation.png",
                      "../../images/Engine/AI/WorldEditScale.png",
                      "../../images/Engine/AI/WorldEditRotation.png",
                      "../../images/Engine/AI/NodeVisibilityCheck.png",
                      "../../images/Engine/AI/PathRemoval.png",
                      "../../images/Engine/AI/AStarFlyToNodes.png",
                      "../../images/Engine/AI/AStarPathFollowing.png",
                      "../../images/Engine/AI/AStarPathsOnly.png",
                      "../../images/Engine/AI/Pursuit.png",
                      "../../images/Engine/AI/Wander.png",
                      "../../images/Engine/AI/Evasion.png",
                      "../../images/Engine/AI/Flocking.png",
                      "../../images/Engine/AI/DargonCeption.png",
                      "../../images/Engine/AI/ForFunDenseGalaxy.png",
                      "../../images/Engine/AI/ForFunFractalDargon.png",
                      "../../images/Engine/AI/ForFunGalaxy.png",
                      "../../images/Engine/AI/ForFunGalaxyHelix.png",
                      "../../images/Engine/AI/ForFunGalaxySpiral.png"],
            "titles": ["Lab 2: Better Spatial Partitioning",
                       "Lab 3: Empty World Editor", 
                       "Lab 4: World Editor Object Placing", 
                       "Lab 4: World Editor Object Removal", 
                       "Lab 4: World Editor Object Translation", 
                       "Lab 4: World Editor Object Scaling", 
                       "Lab 4: World Editor Object Rotation", 
                       "Lab 5: World Editor Node Visiblity Check", 
                       "Lab 5: World Editor Node Removal", 
                       "Lab 6: World Editor Fly To AStar Nodes", 
                       "Lab 6: World Editor AStar Path Following", 
                       "Lab 6: World Editor AStar Paths Only", 
                       "Lab 7: Pursuit", 
                       "Lab 7: Wandering", 
                       "Lab 7: Evasion",
                       "Lab 7: Flocking",
                       "Lab 7: Offset Pursuit",
                       "For Fun: Dense Fractal Galaxy",
                       "For Fun: Fractal Dragon",
                       "For Fun: Fractal Galaxy",
                       "For Fun: Fractal Galaxy Helix",
                       "For Fun: Fractal Galaxy Spiral"],
            "descriptions": ["I enhance my spatial partitioning scheme to not only go from a 2D Uniform Grid to a 3D Uniform Grid, but to also include layers so collisions can be tested against on only necessary layers, and debug functionality to render the grids and display only specific layers.", 
                             "The beginning of something cool... A world editor that will save out object data for reading in by my game engine so objects can be placed conveniently without tyipng code.", 
                             "Using raycasting, I place objects down in 3D space. Here you see a clever use of this.", 
                             "Again with raycasting, I select objects to delete, change their tint color on hover, and remove them on click.", 
                             "By adding math to my game engine, I translate objects with translation arrows rather than keyboard controls.", 
                             "Still using math, I scale objects with scaling arrows rather than keyboard controls.", 
                             "With more math, I rotate objects with rotation arrows rather than keyboard controls. I didn't have a 3D model for curvy arrows.", 
                             "A star nodes are placed in the world, and raycasts are used to check for valid paths between the nodes. These paths are saved out to a file for loading in the game so paths do not have to be calculated during the execution of the game.", 
                             "Unwanted node paths can be removed to allow for one-way node movement (such as going down a ledge and not back up)", 
                             "For any arbitrary world created with the world editor, it can be loaded into the game, and the spawned dragons will fly to the nearest AStar Pathing Node", 
                             "Once on a node, dragons will use AStar pathfinding to navigate between the nodes to reach their desired destination efficiently.", 
                             "Just a fun debug feature, using my layers and partitioning debug functionality, we can show only the paths the dragons are following.", 
                             "Here dragons use the Pursuit Steering Behavior to follow the player.", 
                             "Here dragons use the Wandering Steering Behavior to move randomly without jittering all over the place.", 
                             "Here dragons use the Evasion Steering Behavior to avoid the player with ease.", 
                             "Here dragons use a combination of Cohesion Alignment and Separation to flock!", 
                             "Here I make use of the Offset Pursuit Steering Behavior to make a dragon out of dragons! Yes, it will work for other models.", 
                             "Here I expanded upon the instanced rendering functionality of my engine, in a desperate attempt to optimzie it, and demonstrated this using a galaxy of spheres using my fractal shader.", 
                             "Here I make a dragon out of thousands of fractal spheres, using instanced rendering again, for fun - not as an assignment.", 
                             "Here is another galaxy of fractal spheres created for fun, with instanced rendering.", 
                             "A more vertical Fractal Galaxy made for fun with instanced rendering.",
                             "Yet another Fractal Galaxy made for fun with instanced rendering."]
        }
    },
    "physics":{
        "imageData" : {
            "count": 6, 
            "paths": ["../../images/Engine/Physics/ManySpheres.png",
                      "../../images/Engine/Physics/Momentum.png",
                      "../../images/Engine/Physics/Drag.png",
                      "../../images/Engine/Physics/RestingContact.png",
                      "../../images/Engine/Physics/Spring.png",
                      "../../images/Engine/Physics/SpinnyStuff.png"],
            "titles": ["Lab 1: Many Colliding Spheres",
                       "Lab 2: Conservation of Momentum", 
                       "Lab 3: Drag", 
                       "Lab 4: Resting Contact", 
                       "Lab 5: Spings",
                       "Lab 6: Angular Velocity"],
            "descriptions": ["Here I implement simply sphere-sphere collision and collision resolution in my engine. Here you see (some of) hundreds of spheres that exist in the scene and collide with eachother efficiently.",
                             "Here I implement conservation of momentum in the engine, and have a demo of objects whose masses can be changed, and will speed up or slow down accordingly, to preserve their momentum.",
                             "Here I implement simple drag forces in my engine, causing objects to slow down depending on the specified drag coefficients.",
                             "Here I get spheres stacking successfully by implementing resting contact in my game engine. Spheres can be knocked over by launching another sphere at them and they will bounce.",
                             "Here I get a working spring force, where one sphere is attached to another via an invisible spring. Closer than the specified distance and the second sphere is pushed away, further and it is pulled closer. Spring constants and resting lengths can be modified at runtime.",
                             "Here we work with angular velocity, and allow an object to be detached from it's parent object that it rotates with, but allow it to preserve it's angular momentum while doing so."]
        }
    }
}